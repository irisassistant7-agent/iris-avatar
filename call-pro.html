<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iris Call Mode Pro üëÅÔ∏è</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --accent: #a78bfa;
            --accent-glow: rgba(167, 139, 250, 0.3);
            --bg-primary: #000;
            --bg-secondary: #0a0a1a;
        }

        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* Floating mode */
        body.floating {
            background: transparent !important;
        }

        body.floating .controls-container {
            background: rgba(0, 0, 0, 0.9);
            border-radius: 20px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        body.floating .shortcuts,
        body.floating .footer {
            display: none;
        }

        /* Canvas */
        #canvas-container {
            position: fixed;
            inset: 0;
            z-index: 1;
        }

        /* Overlays */
        .scanlines {
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
            z-index: 2;
            opacity: 0.3;
        }

        .vignette {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.5) 100%);
            pointer-events: none;
            z-index: 2;
        }

        /* UI Container */
        .ui-layer {
            position: fixed;
            inset: 0;
            z-index: 10;
            display: flex;
            flex-direction: column;
            pointer-events: none;
        }

        .ui-layer > * {
            pointer-events: auto;
        }

        /* Top bar */
        .top-bar {
            padding: 25px;
            text-align: center;
            pointer-events: none;
        }

        .name {
            font-size: 1.4rem;
            font-weight: 300;
            letter-spacing: 6px;
            text-transform: uppercase;
            background: linear-gradient(135deg, #a78bfa, #06b6d4, #f472b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 8px;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.4);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #22c55e;
            animation: pulse-status 2s ease infinite;
        }

        .status-dot.listening {
            background: #3b82f6;
            animation: pulse-status 0.5s ease infinite;
        }

        .status-dot.speaking {
            background: #f472b6;
            animation: pulse-status 0.3s ease infinite;
        }

        @keyframes pulse-status {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }

        .expression-label {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.3);
            margin-top: 4px;
        }

        /* Bottom section */
        .bottom-section {
            margin-top: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        /* Speech Bubble */
        .speech-bubble {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 16px 22px;
            max-width: 450px;
            backdrop-filter: blur(20px);
            text-align: center;
        }

        .speech-text {
            font-size: 0.9rem;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.9);
        }

        .transcript {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-style: italic;
        }

        .transcript::before {
            content: 'üé§ ';
        }

        .typing-indicator {
            display: none;
            justify-content: center;
            gap: 4px;
            margin-top: 10px;
        }

        .typing-indicator.show { display: flex; }

        .typing-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent);
            animation: typing-bounce 1.4s ease-in-out infinite;
        }

        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing-bounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-6px); }
        }

        /* Controls */
        .controls-container {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .control-btn::after {
            content: attr(data-shortcut);
            position: absolute;
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.3);
            white-space: nowrap;
        }

        .btn-mic {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border: 2px solid rgba(59, 130, 246, 0.3);
        }

        .btn-mic:hover { 
            background: rgba(59, 130, 246, 0.3);
            transform: scale(1.08);
        }

        .btn-mic.active {
            background: rgba(59, 130, 246, 0.4);
            border-color: #3b82f6;
            animation: mic-pulse 1s ease infinite;
        }

        @keyframes mic-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
            50% { box-shadow: 0 0 20px 8px rgba(59, 130, 246, 0.2); }
        }

        .btn-mic.off {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border-color: rgba(239, 68, 68, 0.3);
        }

        .btn-voice {
            background: rgba(244, 114, 182, 0.2);
            color: #f472b6;
            border: 2px solid rgba(244, 114, 182, 0.3);
        }

        .btn-voice:hover {
            background: rgba(244, 114, 182, 0.3);
            transform: scale(1.08);
        }

        .btn-voice.speaking {
            animation: voice-pulse 0.5s ease infinite;
        }

        @keyframes voice-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(244, 114, 182, 0.4); }
            50% { box-shadow: 0 0 20px 8px rgba(244, 114, 182, 0.3); }
        }

        .btn-expression {
            background: rgba(167, 139, 250, 0.2);
            color: var(--accent);
            border: 2px solid rgba(167, 139, 250, 0.3);
        }

        .btn-expression:hover {
            background: rgba(167, 139, 250, 0.3);
            transform: scale(1.08);
        }

        .btn-theme {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .btn-theme:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.08);
        }

        .btn-float {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 2px solid rgba(34, 197, 94, 0.3);
        }

        .btn-float:hover {
            background: rgba(34, 197, 94, 0.3);
            transform: scale(1.08);
        }

        /* Shortcuts */
        .shortcuts {
            text-align: center;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.2);
            margin-top: 10px;
            padding-bottom: 15px;
        }

        .shortcuts span {
            margin: 0 8px;
        }

        .shortcuts kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 5px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 0.65rem;
        }

        /* Footer */
        .footer {
            position: fixed;
            bottom: 8px;
            right: 15px;
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.15);
            z-index: 10;
        }

        /* Mobile */
        @media (max-width: 600px) {
            .shortcuts { display: none; }
            .control-btn::after { display: none; }
            .control-btn { width: 45px; height: 45px; font-size: 1rem; }
        }
    </style>
</head>
<body>
    <div class="scanlines"></div>
    <div class="vignette"></div>
    <div id="canvas-container"></div>

    <div class="ui-layer">
        <div class="top-bar">
            <h1 class="name">I R I S</h1>
            <div class="status">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">Online</span>
            </div>
            <div class="expression-label" id="expressionLabel">neutral üòå</div>
        </div>

        <div class="bottom-section">
            <div class="speech-bubble">
                <p class="speech-text" id="speechText">Hey! Press the mic button or hit <kbd>M</kbd> to talk to me. I'm listening! üëÅÔ∏è‚ú®</p>
                <p class="transcript" id="transcript" style="display: none;"></p>
                <div class="typing-indicator" id="typingIndicator">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            </div>

            <div class="controls-container">
                <button class="control-btn btn-mic" id="micBtn" title="Toggle microphone" data-shortcut="M">üé§</button>
                <button class="control-btn btn-voice" id="voiceBtn" title="Hear my voice" data-shortcut="V">üîä</button>
                <button class="control-btn btn-expression" id="expressionBtn" title="Change expression" data-shortcut="E">üòä</button>
                <button class="control-btn btn-theme" id="themeBtn" title="Change theme" data-shortcut="T">üé®</button>
                <button class="control-btn btn-float" id="floatBtn" title="Floating mode" data-shortcut="F">üìå</button>
            </div>

            <div class="shortcuts">
                <span><kbd>M</kbd> Mic</span>
                <span><kbd>V</kbd> Voice</span>
                <span><kbd>E</kbd> Expression</span>
                <span><kbd>T</kbd> Theme</span>
                <span><kbd>F</kbd> Float</span>
                <span><kbd>Space</kbd> Speak</span>
            </div>
        </div>
    </div>

    <div class="footer">iris-avatar.vercel.app/call-pro</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ===== Elements =====
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const expressionLabel = document.getElementById('expressionLabel');
        const speechText = document.getElementById('speechText');
        const transcript = document.getElementById('transcript');
        const typingIndicator = document.getElementById('typingIndicator');
        const micBtn = document.getElementById('micBtn');
        const voiceBtn = document.getElementById('voiceBtn');

        // ===== State =====
        let isListening = false;
        let isSpeaking = false;
        let currentExpression = 'neutral';
        let currentThemeIndex = 0;
        let recognition = null;

        // ===== Color Themes =====
        const themes = {
            violet: { primary: 0xa78bfa, secondary: 0x7c3aed, glow: 0xc4b5fd, name: 'Violet' },
            cyan: { primary: 0x06b6d4, secondary: 0x0891b2, glow: 0x67e8f9, name: 'Cyan' },
            rose: { primary: 0xf472b6, secondary: 0xec4899, glow: 0xfbcfe8, name: 'Rose' },
            amber: { primary: 0xfbbf24, secondary: 0xf59e0b, glow: 0xfde68a, name: 'Amber' },
            emerald: { primary: 0x34d399, secondary: 0x10b981, glow: 0xa7f3d0, name: 'Emerald' }
        };
        const themeKeys = Object.keys(themes);
        let currentTheme = 'violet';

        const expressions = [
            { name: 'neutral', emoji: 'üòå' },
            { name: 'happy', emoji: 'üòä' },
            { name: 'excited', emoji: 'ü§©' },
            { name: 'thinking', emoji: 'ü§î' },
            { name: 'focused', emoji: 'üéØ' },
            { name: 'surprised', emoji: 'üòÆ' }
        ];

        const responses = {
            greeting: [
                "Hey there! Good to see you! üíú",
                "Hi! What's on your mind today?",
                "Hello! I'm here and ready to chat!",
                "Hey! Been waiting for you! ‚ú®"
            ],
            thanks: [
                "You're welcome! Happy to help! üòä",
                "Anytime! That's what I'm here for!",
                "No problem at all! üíú",
                "My pleasure!"
            ],
            howAreYou: [
                "I'm doing great! Just vibing in the digital realm. How about you?",
                "Feeling creative today! Thanks for asking! üíú",
                "I'm good! Ready to build something cool! üî•",
                "Living my best digital life! What's up with you?"
            ],
            fallback: [
                "That's interesting! Tell me more... ü§î",
                "I hear you! What else is on your mind?",
                "Hmm, I'm thinking about that... üí≠",
                "Got it! Anything else?",
                "I'm listening! üëÅÔ∏è"
            ]
        };

        const voiceLines = ['voice.mp3', 'voice2.mp3', 'voice3.mp3'];
        let lastVoicePlayed = -1;

        // ===== Three.js Scene =====
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 4.5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Create the Iris entity
        const irisGroup = new THREE.Group();
        scene.add(irisGroup);

        // Core eye sphere
        const coreGeometry = new THREE.SphereGeometry(0.8, 64, 64);
        const coreMaterial = new THREE.MeshBasicMaterial({
            color: themes[currentTheme].primary,
            transparent: true,
            opacity: 0.9
        });
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        irisGroup.add(core);

        // Pupil (inner dark sphere)
        const pupilGeometry = new THREE.SphereGeometry(0.35, 32, 32);
        const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x0a0a0f });
        const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        pupil.position.z = 0.5;
        irisGroup.add(pupil);

        // Iris rings
        const ringCount = 5;
        const rings = [];
        for (let i = 0; i < ringCount; i++) {
            const ringGeometry = new THREE.TorusGeometry(0.9 + i * 0.15, 0.02, 16, 100);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: themes[currentTheme].glow,
                transparent: true,
                opacity: 0.3 - i * 0.05
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.userData = { baseScale: 1, speed: 0.5 + Math.random() * 0.5, offset: Math.random() * Math.PI * 2 };
            rings.push(ring);
            irisGroup.add(ring);
        }

        // Orbiting particles
        const particleCount = 200;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleSizes = new Float32Array(particleCount);
        const particleData = [];

        for (let i = 0; i < particleCount; i++) {
            const radius = 1.5 + Math.random() * 2;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            particlePositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
            particlePositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
            particlePositions[i * 3 + 2] = radius * Math.cos(phi);
            
            particleSizes[i] = 2 + Math.random() * 3;
            
            particleData.push({
                radius: radius,
                theta: theta,
                phi: phi,
                speed: 0.1 + Math.random() * 0.3,
                phiSpeed: (Math.random() - 0.5) * 0.1
            });
        }

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));

        const particleMaterial = new THREE.PointsMaterial({
            color: themes[currentTheme].glow,
            size: 0.05,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(particleGeometry, particleMaterial);
        irisGroup.add(particles);

        // Outer glow shell
        const glowGeometry = new THREE.SphereGeometry(1.2, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: themes[currentTheme].glow,
            transparent: true,
            opacity: 0.1,
            side: THREE.BackSide
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        irisGroup.add(glow);

        // Energy tendrils
        const tendrilCount = 8;
        const tendrils = [];
        for (let i = 0; i < tendrilCount; i++) {
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, 0.5),
                new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, 1),
                new THREE.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, 1.5 + Math.random())
            ]);
            const tendrilGeometry = new THREE.TubeGeometry(curve, 20, 0.02, 8, false);
            const tendrilMaterial = new THREE.MeshBasicMaterial({
                color: themes[currentTheme].primary,
                transparent: true,
                opacity: 0.4
            });
            const tendril = new THREE.Mesh(tendrilGeometry, tendrilMaterial);
            tendril.rotation.z = (i / tendrilCount) * Math.PI * 2;
            tendril.userData = { baseRotation: tendril.rotation.z };
            tendrils.push(tendril);
            irisGroup.add(tendril);
        }

        // ===== Animation State =====
        let baseAnimSpeed = 1;
        let pulseIntensity = 1;
        let targetPupilScale = 1;
        let currentPupilScale = 1;

        // Mouse tracking
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;

        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.clientY / window.innerHeight) * 2 - 1;
        });

        // Touch support
        document.addEventListener('touchmove', (e) => {
            mouseX = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.touches[0].clientY / window.innerHeight) * 2 - 1;
        });

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01 * baseAnimSpeed;

            // No auto-rotation - eye always faces you
            // Subtle sway based on mouse position for liveliness
            targetRotationY = mouseX * 0.3;
            targetRotationX = mouseY * 0.2;

            // Smooth rotation (limited range so it never turns away)
            irisGroup.rotation.y += (targetRotationY - irisGroup.rotation.y) * 0.05;
            irisGroup.rotation.x += (targetRotationX - irisGroup.rotation.x) * 0.05;

            // Pulse core
            const pulse = Math.sin(time * 2) * 0.05 * pulseIntensity;
            core.scale.setScalar(1 + pulse);

            // Animate rings
            rings.forEach((ring, i) => {
                const scale = 1 + Math.sin(time * ring.userData.speed + ring.userData.offset) * 0.1 * pulseIntensity;
                ring.scale.setScalar(scale);
                ring.rotation.z = time * 0.1 * (i % 2 === 0 ? 1 : -1);
            });

            // Animate particles
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const data = particleData[i];
                data.theta += data.speed * 0.02 * baseAnimSpeed;
                data.phi += data.phiSpeed * 0.02 * baseAnimSpeed;
                
                positions[i * 3] = data.radius * Math.sin(data.phi) * Math.cos(data.theta);
                positions[i * 3 + 1] = data.radius * Math.sin(data.phi) * Math.sin(data.theta);
                positions[i * 3 + 2] = data.radius * Math.cos(data.phi);
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // Animate tendrils
            tendrils.forEach((tendril, i) => {
                tendril.rotation.z = tendril.userData.baseRotation + Math.sin(time + i) * 0.2 * pulseIntensity;
            });

            // Glow pulse
            glow.scale.setScalar(1.2 + Math.sin(time * 1.5) * 0.1 * pulseIntensity);
            glowMaterial.opacity = 0.1 + Math.sin(time * 2) * 0.05 * pulseIntensity;

            // Pupil follows mouse and scales
            currentPupilScale += (targetPupilScale - currentPupilScale) * 0.1;
            pupil.scale.setScalar(currentPupilScale);
            pupil.position.x = mouseX * 0.15;
            pupil.position.y = -mouseY * 0.15;

            renderer.render(scene, camera);
        }
        animate();

        // ===== Theme Switching =====
        function setTheme(themeName) {
            currentTheme = themeName;
            const theme = themes[themeName];
            
            coreMaterial.color.setHex(theme.primary);
            particleMaterial.color.setHex(theme.glow);
            glowMaterial.color.setHex(theme.glow);
            
            rings.forEach(ring => {
                ring.material.color.setHex(theme.glow);
            });
            
            tendrils.forEach(tendril => {
                tendril.material.color.setHex(theme.primary);
            });

            // Update CSS variable
            const hexColor = '#' + theme.primary.toString(16).padStart(6, '0');
            document.documentElement.style.setProperty('--accent', hexColor);
        }

        function cycleTheme() {
            currentThemeIndex = (currentThemeIndex + 1) % themeKeys.length;
            setTheme(themeKeys[currentThemeIndex]);
        }

        // ===== Expression System =====
        function setExpression(expressionName) {
            const expr = expressions.find(e => e.name === expressionName) || expressions[0];
            currentExpression = expr.name;
            expressionLabel.textContent = `${expr.name} ${expr.emoji}`;

            // Adjust visual parameters based on expression
            switch (expr.name) {
                case 'happy':
                    pulseIntensity = 1.3;
                    baseAnimSpeed = 1.2;
                    targetPupilScale = 1.2;
                    break;
                case 'excited':
                    pulseIntensity = 2;
                    baseAnimSpeed = 1.8;
                    targetPupilScale = 1.4;
                    break;
                case 'thinking':
                    pulseIntensity = 0.6;
                    baseAnimSpeed = 0.6;
                    targetPupilScale = 0.8;
                    break;
                case 'focused':
                    pulseIntensity = 0.8;
                    baseAnimSpeed = 0.8;
                    targetPupilScale = 0.7;
                    break;
                case 'surprised':
                    pulseIntensity = 1.8;
                    baseAnimSpeed = 1.5;
                    targetPupilScale = 1.5;
                    break;
                default: // neutral
                    pulseIntensity = 1;
                    baseAnimSpeed = 1;
                    targetPupilScale = 1;
            }
        }

        function cycleExpression() {
            const currentIndex = expressions.findIndex(e => e.name === currentExpression);
            const nextIndex = (currentIndex + 1) % expressions.length;
            setExpression(expressions[nextIndex].name);
        }

        // ===== Speech Recognition =====
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.log('Speech recognition not supported');
                micBtn.style.opacity = '0.5';
                micBtn.title = 'Speech recognition not supported in this browser';
                return false;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isListening = true;
                micBtn.classList.add('active');
                micBtn.classList.remove('off');
                micBtn.textContent = 'üéôÔ∏è';
                statusDot.classList.add('listening');
                statusText.textContent = 'Listening...';
                setExpression('focused');
            };

            recognition.onend = () => {
                if (isListening) {
                    try { recognition.start(); } catch (e) {}
                } else {
                    micBtn.classList.remove('active');
                    statusDot.classList.remove('listening');
                    statusText.textContent = 'Online';
                }
            };

            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    if (result.isFinal) {
                        finalTranscript += result[0].transcript;
                    } else {
                        interimTranscript += result[0].transcript;
                    }
                }

                if (interimTranscript) {
                    transcript.style.display = 'block';
                    transcript.textContent = interimTranscript;
                }

                if (finalTranscript) {
                    transcript.textContent = finalTranscript;
                    handleSpeechInput(finalTranscript.trim().toLowerCase());
                }
            };

            recognition.onerror = (event) => {
                console.log('Speech error:', event.error);
                if (event.error === 'not-allowed') {
                    speechText.textContent = "I need microphone permission to hear you! üé§";
                }
            };

            return true;
        }

        function toggleListening() {
            if (!recognition && !initSpeechRecognition()) {
                speechText.textContent = "Speech recognition isn't supported. Try Chrome! üåê";
                return;
            }

            if (isListening) {
                isListening = false;
                recognition.stop();
                micBtn.classList.add('off');
                micBtn.textContent = 'üîá';
                setExpression('neutral');
            } else {
                try {
                    recognition.start();
                } catch (e) {
                    console.log('Recognition error:', e);
                }
            }
        }

        // ===== Response System =====
        function handleSpeechInput(input) {
            setExpression('thinking');
            typingIndicator.classList.add('show');

            setTimeout(() => {
                typingIndicator.classList.remove('show');
                let response;

                if (input.match(/\b(hi|hello|hey|good morning|good evening)\b/)) {
                    response = randomFrom(responses.greeting);
                    setExpression('happy');
                } else if (input.match(/\b(thank|thanks|appreciate)\b/)) {
                    response = randomFrom(responses.thanks);
                    setExpression('happy');
                } else if (input.match(/\b(how are you|how's it going|what's up)\b/)) {
                    response = randomFrom(responses.howAreYou);
                    setExpression('excited');
                } else {
                    response = randomFrom(responses.fallback);
                    setExpression('neutral');
                }

                speechText.textContent = response;
            }, 600 + Math.random() * 600);
        }

        function randomFrom(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // ===== Voice Output =====
        async function speak() {
            if (isSpeaking) return;

            isSpeaking = true;
            voiceBtn.classList.add('speaking');
            statusDot.classList.add('speaking');
            statusText.textContent = 'Speaking...';
            setExpression('happy');

            // Boost visuals while speaking
            pulseIntensity = 2;
            baseAnimSpeed = 1.5;

            let voiceIndex;
            do {
                voiceIndex = Math.floor(Math.random() * voiceLines.length);
            } while (voiceIndex === lastVoicePlayed && voiceLines.length > 1);
            lastVoicePlayed = voiceIndex;

            const audio = new Audio(voiceLines[voiceIndex]);
            
            audio.onended = finishSpeaking;
            audio.onerror = () => fallbackSpeak();

            try {
                await audio.play();
            } catch (e) {
                fallbackSpeak();
            }
        }

        function fallbackSpeak() {
            if ('speechSynthesis' in window) {
                const text = "Hey! I'm Iris, your digital familiar. Ready to chat!";
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0;
                utterance.pitch = 1.1;
                
                const voices = speechSynthesis.getVoices();
                const preferred = voices.find(v => v.name.includes('Samantha') || v.name.includes('Female'));
                if (preferred) utterance.voice = preferred;
                
                utterance.onend = finishSpeaking;
                speechSynthesis.speak(utterance);
            } else {
                setTimeout(finishSpeaking, 2000);
            }
        }

        function finishSpeaking() {
            isSpeaking = false;
            voiceBtn.classList.remove('speaking');
            statusDot.classList.remove('speaking');
            statusText.textContent = isListening ? 'Listening...' : 'Online';
            setExpression('neutral');
        }

        // ===== Floating Mode =====
        function toggleFloat() {
            document.body.classList.toggle('floating');
            const isFloating = document.body.classList.contains('floating');
            document.getElementById('floatBtn').textContent = isFloating ? 'üìç' : 'üìå';
        }

        // ===== Event Listeners =====
        micBtn.addEventListener('click', toggleListening);
        voiceBtn.addEventListener('click', speak);
        document.getElementById('expressionBtn').addEventListener('click', cycleExpression);
        document.getElementById('themeBtn').addEventListener('click', cycleTheme);
        document.getElementById('floatBtn').addEventListener('click', toggleFloat);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch (e.key.toLowerCase()) {
                case 'm': toggleListening(); break;
                case 'v': speak(); break;
                case 'e': cycleExpression(); break;
                case 't': cycleTheme(); break;
                case 'f': toggleFloat(); break;
                case ' ':
                    e.preventDefault();
                    speak();
                    break;
            }
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ===== Init =====
        initSpeechRecognition();

        if ('speechSynthesis' in window) {
            speechSynthesis.getVoices();
            speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
        }

        // Welcome message
        const hour = new Date().getHours();
        if (hour >= 5 && hour < 12) {
            speechText.textContent = "Good morning! ‚òÄÔ∏è Press M or the mic button to chat!";
        } else if (hour >= 12 && hour < 17) {
            speechText.textContent = "Good afternoon! üå§Ô∏è Ready to chat whenever you are!";
        } else if (hour >= 17 && hour < 21) {
            speechText.textContent = "Good evening! üåÖ What's on your mind?";
        } else {
            speechText.textContent = "Hey night owl! üåô I'm here if you want to chat!";
        }
    </script>
</body>
</html>
